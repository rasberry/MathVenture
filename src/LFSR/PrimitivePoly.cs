// =============================================================================
// Note: Substantial portions of the source code contained in this file are a
// derivative of the FTX library by Jörg Arndt - https://www.jjj.de/
// Copyright (c) 2010, 2012, 2014 Jörg Arndt
// All code contained in this file is released with the following license:
//
// License: GNU General Public License version 3 or later.
// see https://www.gnu.org/licenses/
//
// =============================================================================

using System;
using System.Numerics;

namespace MathVenture.LFSR;

/// <summary>
/// This class constructs random primitive polynomials represented as
///  bits in a integer structure (ulong) (see https://en.wikipedia.org/wiki/GF%282%29)
/// </summary>
public static class PrimitivePoly
{
	const int BitsPerLong = 64;
	static Random Rnd = new Random();

	/// <summary>
	/// Generates a random primitive polynomial with the given bit depth
	/// </summary>
	/// <param name="bitCount">bit depth [1-63]</param>
	/// <returns>bit representation of the polynomial</returns>
	public static ulong GetRandomPoly(int bitCount)
	{
		ulong poly, seed;
		do {
			seed = (ulong)Rnd.NextInt64();
		}
		while(!TryGetPolyFromSeed(seed, bitCount, out poly));

		return poly;
	}

	/// <summary>
	/// Create a polynomial from a given seed.
	/// </summary>
	/// <param name="seed">The generator seed.</param>
	/// <param name="bitCount">bit depth [1-63]</param>
	/// <param name="poly">bit representation of the polynomial</param>
	/// <returns>Returns false is the seed is invalid (not primitive)</returns>
	public static bool TryGetPolyFromSeed(ulong seed, int bitCount, out ulong poly)
	{
		if (bitCount < 1 || bitCount >= BitsPerLong) {
			throw new ArgumentOutOfRangeException(nameof(bitCount));
		}

		poly = 0ul;
		if (!IsValid(seed,bitCount)) {
			return false;
		}

		poly = GetPolyFromSeed(seed,bitCount);
		poly >>= 1;
		return true;
	}

	// check for primitive powers
	static bool IsValid(ulong seed, int bits)
	{
		if (bits == 0) { return false; }

		ulong mask = ulong.MaxValue;
		if (bits < BitsPerLong) {
			mask = (1ul << bits) - 1;
		}

		return GreatestCommonDivisor(seed,mask) == 1;
	}

	static T GreatestCommonDivisor<T>(T a, T b) where T : IBinaryInteger<T>
	{
		while (!T.IsZero(b)) {
			T r = a % b;
			a = b;
			b = r;
		}
		return a;
	}

	// create the primitive polynomial from a 'valid' seed
	static ulong GetPolyFromSeed(ulong seed, int bits)
	{
		ulong mod = LowBitPimitive(bits);
		ulong genc = 2ul;
		ulong mask = 1ul << (bits - 1);

		ulong s = ModPower(genc,seed,mod,mask);
		ulong x = 2ul;
		ulong m = 1ul;

		for(ulong i = 0; i < (ulong)bits; i++) {
			ulong t = x ^ s;
			m = PolyModMultiply(m,t,mod,mask);
			s = PolyModSquare(s,mod,mask);
		}
		return m ^ mod;
	}

	// return polynomial (A ** e) mod C
	static ulong ModPower(ulong a, ulong e, ulong c, ulong h)
	{
		ulong s = a;
		ulong b = SetOnlyHighBit(e);
		while(b > 1ul) {
			b >>= 1;
			s = PolyModSquare(s,c,h); // s *= s;
			if ((e & b) != 0) {
				s = PolyModMultiply(s,a,c,h); // s *= a;
			}
		}
		return s;
	}

	// return number where only the highest bit in x is set.
	// return 0 if no bit is set.
	static ulong SetOnlyHighBit(ulong x)
	{
		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		x |= x >> 8;
		x |= x >> 16;
		x |= x >> 32;
		return  x ^ (x >> 1);
	}

	// return A * A mod C
	static ulong PolyModSquare(ulong a, ulong c, ulong h)
	{
		return PolyModMultiply(a, a, c, h);
	}

	// return  (A * B) mod C
	// must have deg(A) < deg(C) and deg(B) < deg(C)
	static ulong PolyModMultiply(ulong a, ulong b, ulong c, ulong h)
	{
		ulong t = 0ul;
		do {
			if ((b & 1ul) != 0ul) { t ^= a; }
			b >>= 1;

			ulong s = a & h;
			a <<= 1;
			if (s != 0ul) { a ^= c; }
		}
		while(b != 0ul);
		return t;
	}

	//  primitive polynomials over Z/2Z
	//  with lowest-most possible set bits.
	//  These are the minimal numbers with the corresponding
	//  polynomial of given degree primitive.
	//
	//  Generated by Jörg Arndt, 2002-12-21
	static ulong LowBitPimitive(int bits)
	{
		switch(bits) {
			//              hex_val,             // dec_val            (bits)  [weight]
			case 00: return 0x1                ; // 1                    (00)  [1]
			case 01: return 0x3                ; // 3                    (01)  [2]
			case 02: return 0x7                ; // 7                    (02)  [3]
			case 03: return 0xb                ; // 11                   (03)  [3]
			case 04: return 0x13               ; // 19                   (04)  [3]
			case 05: return 0x25               ; // 37                   (05)  [3]
			case 06: return 0x43               ; // 67                   (06)  [3]
			case 07: return 0x83               ; // 131                  (07)  [3]
			case 08: return 0x11d              ; // 285                  (08)  [5]
			case 09: return 0x211              ; // 529                  (09)  [3]
			case 10: return 0x409              ; // 1033                 (10)  [3]
			case 11: return 0x805              ; // 2053                 (11)  [3]
			case 12: return 0x1053             ; // 4179                 (12)  [5]
			case 13: return 0x201b             ; // 8219                 (13)  [5]
			case 14: return 0x402b             ; // 16427                (14)  [5]
			case 15: return 0x8003             ; // 32771                (15)  [3]
			case 16: return 0x1002d            ; // 65581                (16)  [5]
			case 17: return 0x20009            ; // 131081               (17)  [3]
			case 18: return 0x40027            ; // 262183               (18)  [5]
			case 19: return 0x80027            ; // 524327               (19)  [5]
			case 20: return 0x100009           ; // 1048585              (20)  [3]
			case 21: return 0x200005           ; // 2097157              (21)  [3]
			case 22: return 0x400003           ; // 4194307              (22)  [3]
			case 23: return 0x800021           ; // 8388641              (23)  [3]
			case 24: return 0x100001b          ; // 16777243             (24)  [5]
			case 25: return 0x2000009          ; // 33554441             (25)  [3]
			case 26: return 0x4000047          ; // 67108935             (26)  [5]
			case 27: return 0x8000027          ; // 134217767            (27)  [5]
			case 28: return 0x10000009         ; // 268435465            (28)  [3]
			case 29: return 0x20000005         ; // 536870917            (29)  [3]
			case 30: return 0x40000053         ; // 1073741907           (30)  [5]
			case 31: return 0x80000009         ; // 2147483657           (31)  [3]
			case 32: return 0x1000000af        ; // 4294967471           (32)  [7]
			case 33: return 0x200000053        ; // 8589934675           (33)  [5]
			case 34: return 0x4000000e7        ; // 17179869415          (34)  [7]
			case 35: return 0x800000005        ; // 34359738373          (35)  [3]
			case 36: return 0x1000000077       ; // 68719476855          (36)  [7]
			case 37: return 0x200000003f       ; // 137438953535         (37)  [7]
			case 38: return 0x4000000063       ; // 274877907043         (38)  [5]
			case 39: return 0x8000000011       ; // 549755813905         (39)  [3]
			case 40: return 0x10000000039      ; // 1099511627833        (40)  [5]
			case 41: return 0x20000000009      ; // 2199023255561        (41)  [3]
			case 42: return 0x4000000003f      ; // 4398046511167        (42)  [7]
			case 43: return 0x80000000059      ; // 8796093022297        (43)  [5]
			case 44: return 0x100000000065     ; // 17592186044517       (44)  [5]
			case 45: return 0x20000000001b     ; // 35184372088859       (45)  [5]
			case 46: return 0x40000000012f     ; // 70368744177967       (46)  [7]
			case 47: return 0x800000000021     ; // 140737488355361      (47)  [3]
			case 48: return 0x10000000000b7    ; // 281474976710839      (48)  [7]
			case 49: return 0x2000000000071    ; // 562949953421425      (49)  [5]
			case 50: return 0x400000000001d    ; // 1125899906842653     (50)  [5]
			case 51: return 0x800000000004b    ; // 2251799813685323     (51)  [5]
			case 52: return 0x10000000000009   ; // 4503599627370505     (52)  [3]
			case 53: return 0x20000000000047   ; // 9007199254741063     (53)  [5]
			case 54: return 0x4000000000007d   ; // 18014398509482109    (54)  [7]
			case 55: return 0x80000000000047   ; // 36028797018964039    (55)  [5]
			case 56: return 0x100000000000095  ; // 72057594037928085    (56)  [5]
			case 57: return 0x20000000000002d  ; // 144115188075855917   (57)  [5]
			case 58: return 0x400000000000063  ; // 288230376151711843   (58)  [5]
			case 59: return 0x80000000000007b  ; // 576460752303423611   (59)  [7]
			case 60: return 0x1000000000000003 ; // 1152921504606846979  (60)  [3]
			case 61: return 0x2000000000000027 ; // 2305843009213693991  (61)  [5]
			case 62: return 0x4000000000000069 ; // 4611686018427388009  (62)  [5]
			case 63: return 0x8000000000000003 ; // 9223372036854775811  (63)  [3]
		}

		throw new ArgumentOutOfRangeException(nameof(bits));
	}
}
